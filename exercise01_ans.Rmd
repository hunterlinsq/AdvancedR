---
title: "exercise01_answer"
author: "linsq"
date: "2017年3月13日"
output: 
  pdf_document: 
    latex_engine: xelatex
    includes:
          in_header: header.tex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 题目

- 求同一类资产同时出现在一个时间范围的最大次数及所在id。如下面样例数据中dow这个产品在id=c(30,40,50) 这三个区间中都出现，同时dow这个产品在id=c(30,40,60)这三个区间也同时出现过（所谓同时出现，就是这几个id时间范围有重叠区间）。因此，dow在同时出现在一个时间范围的最大次数为3，所在id为：id=c(30,40,50)以及id=c(30,40,60)。建议同学先把样本数据print出来看下数据结构，再看题目。有疑问先在群上提问，把题目弄清楚了，再下笔写程序。

- 可以使用向量、dplyr、data.table、Rcpp等工具实现


```{r}
ds<-data.frame(id=seq(10,80,by=10),
               anest=c("baker","baker",rep("dow",6)),
               start=c("08:00","09:00","09:00","08:00","10:00","12:30","13:30","18:00"),
               end=c("11:00","13:00","15:30","13:30","11:30","13:30","14:30","19:00"))
ds

```


##solution1
基本思路：对于某个资产，由于题目的时间是factor，将其start和end合并在一起经过一系列转化成类似区间这样的形式，对于这样得到每一个端点，比如1，再加上0.5，此时1.5代表区间（1，2），看其是否落在每一个id的区间里面(利用dplyr::between),返回TRUE说明该ID经过该时间段，这样如此反复，返回TRUE最多的X+0.5就代表dow在该时间段上出现的次数最多，最后再反过来再找到X+0.5都为TRUE对应的ID们。
```{r}
library(data.table)
overlap <- function(asset,data){
        data <- data.table(data)
        data_asset <- data[anest==asset,]
        level <- as.numeric(as.factor(c(as.character(data_asset$start),
                                        as.character(data_asset$end))))  #将时间排序
        data_asset <- data_asset[,.(id,start1=level[1:(length(level)/2)],
                                    end1=level[-c(1:(length(level)/2))])] #类似区间形式
        m <- length(unique(level))
        for(i in 1:m){
        dasset <- data_asset[,paste("V",i+0.5,sep = ""):=dplyr::between(i+0.5,start1,end1),by=id]
        } #各区间有没有出现在样本上
        name <- colnames(dasset)
        nums <- dasset[,lapply(.SD[,which(name=="V1.5"):which(name==paste("V",m+0.5,sep = ""))],sum)] #各个区间上的重叠数
        max_inter <- colnames(nums)[which(nums==max(nums))]  #最大重叠数对应的区间
        max_where <- which(name %in% max_inter)   #此区间对应在数据中的列数
        result <- list("number"=NA,"id"=NULL)
        result$number <- max(nums)
        dasset2 <- data.frame(dasset)
        for(j in 1:length(max_where)){
                result$id <- rbind(result$id,dasset2[which(dasset2[,max_where[j]]==TRUE),]$id)
                }
        result
}

overlap(asset = "dow",data = ds)
overlap(asset = "baker",data = ds)

library(microbenchmark)
microbenchmark(overlap(asset = "dow",data = ds))


Rprof("a.out")
a <- overlap(asset = "dow",data = ds)
Rprof(NULL)
summaryRprof("a.out")
```


改进版
```{r}
overlap_n <- function(asset,data){
        d_a <- data[data$anest==asset,]
        level <- as.numeric(as.factor(c(as.character(d_a$start),
                                        as.character(d_a$end))))  #将时间排序
        d_a$start=level[1:(length(level)/2)]
        d_a$end=level[-c(1:(length(level)/2))] 
        
        inter <- data.frame()
        for(i in 1:nrow(d_a)){
                for(j in 1:length(unique(level))){
                        inter[i,j] <- dplyr::between(j+0.5,d_a$start[i],d_a$end[i])
                }
        }
        
        result <- list("max_number"=NA,"id"=list())
        result$max_number <- max(apply(inter,2,sum))
        max_where<- which(apply(inter,2,sum)==result$max_number)
        for(i in 1:length(max_where)){
                result$id[[i]] <- d_a$id[inter[,max_where[i]]]
                }
        result
}
overlap_n(asset = "dow",data = ds)
microbenchmark(overlap_n(asset = "dow",data = ds))

```


##solution2

```{r}

over <- function(x1,x2,y1,y2){
        ifelse(max(x1,y1)<min(x2,y2),return(TRUE),return(FALSE))
}

overlap2 <- function(asset,data){
        d_a <- data[data$anest==asset,]
        d_a$start<- as.POSIXct(d_a$start,format="%H:%M")
        d_a$end<- as.POSIXct(d_a$end,format="%H:%M")
        level <- unique(sort(c(d_a$start,d_a$end)))
        
        inter <- data.frame()
        for(i in 1:nrow(d_a)){
                for(j in 1:(length(level)-1)){
                        inter[i,j] <- over(d_a$start[i],d_a$end[i],level[j],level[j+1])
                }
        }
        
        result <- list("max_number"=NA,"id"=list())
        result$max_number <- max(apply(inter,2,sum))
        max_where<- which(apply(inter,2,sum)==result$max_number)
        for(i in 1:length(max_where)){result$id[[i]] <- d_a$id[inter[,max_where[i]]]}
        result
}

overlap2(asset = "dow",data = ds)

microbenchmark(overlap2(asset = "dow",data = ds),times = 1000L)

Rprof("a.out")
a <- overlap2(asset = "dow",data = ds)
Rprof(NULL)
summaryRprof("a.out")

```

改进简化版
```{r}
overlap2_n <- function(asset,data){
        d_a <- data[data$anest==asset,]
        d_a$start<- as.POSIXct(d_a$start,format="%H:%M")
        d_a$end<- as.POSIXct(d_a$end,format="%H:%M")
        level <- unique(sort(c(d_a$start,d_a$end)))
        
        inter <- data.frame(row.names = d_a$id)
        for(i in 1:nrow(d_a)){
                for(j in 1:(length(level)-1)){
                        inter[i,j] <- over(d_a$start[i],d_a$end[i],level[j],level[j+1])
                }
        }
        
        max_number <- max(apply(inter,2,sum))
        res<- inter[,which(apply(inter,2,sum)==max_number)]
        return(list("max_number"=max_number,"id"=lapply(res,function(x){row.names(res)[x]})))
}


overlap2_n(asset = "dow",data = ds)
library(microbenchmark)
microbenchmark(overlap2_n(asset = "dow",data = ds),times = 1000L)
```



泽贤的强无敌算法
```{r}
solution3 <- function(asset,data){
        d_a <- data[data$anest==asset,]
        d_a$start<- as.POSIXct(d_a$start,format="%H:%M")
        d_a$end<- as.POSIXct(d_a$end,format="%H:%M")
        
        n <- nrow(d_a)
        f1 <- function(x){
                if(max(d_a[x,]$start) < min(d_a[x,]$end)){
                        d_a[x,"id"]
                }
        }
        
        for( k in n:2){
                index <- combn(n, k, simplify = F)
                res <- Filter(Negate(is.null),lapply(index, f1))
                if(length(res)!=0){
                        result <- list("max_number"=length(res[[1]]),"id"=res)
                        return(result)
                }
        }
}
solution3(asset = "dow",data = ds)
microbenchmark(solution3(asset = "dow",data = ds))

```

